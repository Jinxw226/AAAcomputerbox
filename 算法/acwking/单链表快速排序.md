#单链表快速排序
平均时间复杂度为O(nlogn)   空间复杂度为O(logn)
![[Pasted image 20250812172754.png]]
![[单链表快速排序.png]]

```cpp
/**
 *
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x):val(x), next(nullptr){}
};
class Solution {
public:
    ListNode* get_tail(ListNode* head){
        while(head -> next) head = head -> next;
        return head;
    }
    ListNode* quickSortList(ListNode* head){
        if(!head || !head -> next){
            return head;
        }
        
        auto left = new ListNode(-1),mid = new ListNode(-1),right = new ListNode(-1);
        auto ltail = left , mtail = mid , rtail = right;
        int val = head -> val;
        
        for(auto p = head; p ;p = p -> next){
            if (p -> val < val) ltail = ltail -> next = p;
            else if (p -> val == val) mtail = mtail -> next = p;
            else rtail = rtail -> next = p;
        }

  
        ltail -> next = mtail -> next = rtail -> next = nullptr;
        left -> next = quickSortList(left -> next);
        right -> next = quickSortList(left -> next);


        //拼接三个链表
        get_tail(left) -> next = mid -> next;
        get_tail(left) -> next = right -> next;

        auto p = left -> next;
        delete left;
        delete mid;
        delete right;
        return p;
    }
};
```

稳定的：相对顺序不会改变，链表快排是稳定的

如果要求O(nlogn)的时间复杂度和额外O(1)的空间复杂度对其进行排序，需要使用归并迭代的方式写