**示例 1:**

**输入:** nums = [2,3,1,1,4]
**输出:** 2
**解释:** 跳到最后一个位置的最小跳跃数是 `2`。
     从下标为 0 跳到下标为 1 的位置，跳 `1` 步，然后跳 `3` 步到达数组的最后一个位置。

**示例 2:**

**输入:** nums = [2,3,0,1,4]
**输出:** 2

每个元素 `nums[i]` 表示从索引 `i` 向后跳转的最大长度。换句话说，如果你在索引 `i` 处，你可以跳转到任意 `(i + j)` 处：

- `0 <= j <= nums[i]` 且
- `i + j < n`

返回到达 `n - 1` 的最小跳跃次数。测试用例保证可以到达 `n - 1`。

解法：贪心算法-从前往后找最大能到达的点

初始化三个变量：能走到的最大距离max_far
step  步数    end   跳一步能到达的最右边界

遍历整个数组，找出max_far
并且当跳到最右边界时：i == end时候，就需要再跳一步step++，并且把所有前面点能走到的最大距离max_far赋给end

注意遍历的范围到size-1

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        int max_far = 0, end = 0,step =0;
        for(int  i= 0; i < nums.size() - 1; i++){
            max_far = max(max_far, nums[i]+i);
            if(end == i){
                step++;
                end = max_far;
            }
        }
        return step;
    }
};
```