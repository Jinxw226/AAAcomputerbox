有n个小朋友，并且ratings数组中存放了每个小朋友的评分
- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子中，评分更高的那个会获得更多的糖果。
请返回 需要准备最少糖果数量

解法：两边遍历贪心算法

初始化数组candies中存储每个小朋友需要分到的糖的数量并且初始化为1

先从左至右开始遍历，如果右边的小朋友比左边的小朋友评分高则右边小朋友分到的糖果数量为左边小朋友糖果数量+1

再从右至左开始遍历，如果左边的小朋友评分比右边小朋友的评分高，则在左边小朋友持有的糖果和右边小朋友持有的糖果数量+1 中取得最大值作为左边小朋友的糖果数量

最后遍历一遍candies数组，将每一个值加入total中返回total

```cpp
class Solution {
public:
    int candy(vector<int>& ratings) {
        int n = ratings.size();
        if(n == 0) return 0;

        vector<int> candies(n, 1);

        for(int  i = 1; i < n ; i++){
            if(ratings[i] > ratings[i-1]){
                candies[i] = candies[i - 1] + 1;
            }
        }
        for(int i = n-2; i >= 0; i--){
            if(ratings[i] > ratings[i + 1]){
                candies[i] = max(candies[i], candies[i + 1] + 1);
            }
        }
        int total = 0;
        for(int candy : candies){
            total += candy;
        }

        return total;
    }
};
```

时间复杂度O(n)  空间复杂度O(n)