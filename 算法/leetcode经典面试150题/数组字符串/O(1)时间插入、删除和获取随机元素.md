本题目运用到了vector和unordered_map哈希表
要确保实现每个函数的平均时间复杂度为O(1)
那么插入和删除操作需要用到hash表可以达到时间复杂度为O(1)，取随机值需要用到动态数组vector可以达到时间复杂度为O(1)

hash_map就是键值对，一个数值对应一个索引
      srand((unsigned)time(NULL));
      根据时间不同会返回不同的randomnumber
      否则执行程序返回的值都是一样的
ctime
	取时间的库
unordered_map哈希表库（键值对）
	count(val)：统计所有val值的数量
	indices[val] = index;  给val键映射index值
	indices.erase(val)：删除val键值对
vector动态数组
	emplace_back与push_back的主要区别在于它们的实现机制。push_back在向vector尾部添加元素时，会先创建一个元素，然后将其拷贝或移动到容器中。如果是拷贝操作，之后会自动销毁创建的临时元素。而emplace_back则是直接在容器尾部创建元素，省去了这个中间步骤。
	pop_back：删除最后一个元素


```cpp
#include<vector>
#include<ctime>
#include<cstdlib>
#include<unordered_map>

using namespace std;

class RandomizedSet{
  private:
    vector<int> nums;
    unordered_map<int, int> indices;
  public:
    RandomizedSet(){
      srand((unsigned)time(NULL));
    }

    bool insert(int val){
      if(indices.count(val)){
        return false;
      }
      int index = nums.size();
      nums.emplace_back(val);
      indices[val] = index;
      return true;
    }

    bool remove(int val){
      if(!indices.count(val)){
        return false;
      }
      int index = indices[val];
      int last = nums.back();
      nums[index] = nums.back();
      nums.pop_back();
      indices[last] = index;
      indices.erase(val);
      return true;
    }

    int getRandom(){
      int randomIndex = rand() % nums.size();
      return nums[randomIndex];
    }
};

int main(){
  RandomizedSet randomizedSet = RandomizedSet();
  randomizedSet.insert(1);
  randomizedSet.remove(2);
  randomizedSet.insert(2);
  randomizedSet.getRandom();
  randomizedSet.remove(1);
  randomizedSet.insert(2);
  randomizedSet.getRandom();
  return 0;
}

```