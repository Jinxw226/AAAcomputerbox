解法：采用左右乘积列表方式
求出每个nums中的数字的左边数乘积和右边数字乘积，并且存入answer数组中，可以直接返回nums某一数字的除自身以外数组的乘积。

只用一个数据answer和r来表示右边后缀乘法的结果
先用answer数组存储左边乘积
再初始化r为1从右边第一项开始计算右边乘积，并且在每个数出来的时直接乘 给answer那一项，不需要额外的存储空间，右边乘积算完，answer数组也正是成立

注意需要计算右边后缀是从后往前开始计算
因为左边数从前往后是越来越大
右边数从前往后越来越小

还可以乘所有的数字，要计算某一个位置的数，就将整数除以总乘数，就可以得到
缺点是如果数组中有0，那么就不能采用这种方法

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int length = nums.size();
        vector<int> answer(length);
        answer[0] = 1;
        for(int i = 1;i < length; i++ ){
            answer[i] = answer[i-1] * nums[i-1];
        }

        int r = 1;
        for(int i = length - 1; i >= 0; i--){
            answer[i] = answer[i] * r;
            r = r * nums[i];
        }

        return answer;
    }
};
```

时间复杂度： O(N)   需要遍历
空间复杂度： O(1)  （answer数组占据的内存不计）